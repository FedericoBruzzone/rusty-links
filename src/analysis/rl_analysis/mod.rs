mod rl_args_resolver;
mod rl_call_resolver;
mod rl_context;
pub mod rl_graph;
mod rl_petgraph;
mod rl_visitor;

use super::{
    utils::{MERGED_FILE_NAME, RL_SERDE_FOLDER},
    Analyzer,
};
use rl_graph::{RLEdge, RLGraph, RLIndex, RLNode};
use rl_visitor::RLVisitor;

use rustc_hir::def_id::LOCAL_CRATE;
use rustc_middle::ty;
use serde::{de::DeserializeOwned, Serialize};
use std::{cell::Cell, time::Duration};

pub struct RLAnalysis<'tcx, 'a, G>
where
    G: RLGraph<Node = RLNode, Edge = RLEdge, Index = RLIndex>
        + Default
        + Clone
        + Serialize
        + DeserializeOwned,
{
    analyzer: &'a Analyzer<'tcx, G>,
    krate_name: String,
    elapsed: Cell<Option<Duration>>,
    _marked: std::marker::PhantomData<G>,
}

impl<'tcx, 'a, G> RLAnalysis<'tcx, 'a, G>
where
    G: RLGraph<Node = RLNode, Edge = RLEdge, Index = RLIndex>
        + Default
        + Clone
        + Serialize
        + DeserializeOwned,
{
    pub fn new(analyzer: &'a Analyzer<'tcx, G>) -> Self {
        let krate_name = analyzer.tcx.crate_name(LOCAL_CRATE).to_string();
        Self {
            analyzer,
            krate_name,
            elapsed: Cell::new(None),
            _marked: std::marker::PhantomData,
        }
    }

    fn visitor(&self) -> G {
        let visitor: &mut RLVisitor<'tcx, 'a, G> = &mut RLVisitor::new(self.analyzer);

        // We do not need to call `mir_keys` (self.analyzer.tcx.mir_keys(()))
        // because it returns also the enum and struct constructors
        // automatically generated by the compiler.
        //
        // For example, for the following code
        // ```no_run
        // struct MyStruct(i32);
        // enum MyEnum { Variant(i32) }
        // ```
        // the `mir_keys` returns the following local_def_ids
        // ```no_run
        // MyStruct::{constructor#0})
        // MyEnum::Variant::{constructor#0})
        // ```
        for local_def_id in self.analyzer.tcx.hir_body_owners() {
            // Visit the body of the `local_def_id`
            visitor.visit_local_def_id(
                local_def_id,
                self.analyzer
                    .tcx
                    .instance_mir(ty::InstanceKind::Item(local_def_id.to_def_id())),
            );

            // TODO: Check if the body has some promoted MIR.
            // It is not clear if analyzing the promoted MIR is necessary.
            let _promoted_mir = self.analyzer.tcx.promoted_mir(local_def_id.to_def_id());
        }

        visitor.rl_graph().clone()
    }

    // Currently the serialization is done only to allow the merging of the RLGraphs.
    // The merging is done by the `merge_all_rl_graphs` method, which is used only in tests.
    fn serialize_rl_graph_to_file(&self, rl_graph: &G) {
        std::fs::create_dir_all(RL_SERDE_FOLDER).expect("Failed to create folder");
        let file_name = format!("{}/{}.rlg", RL_SERDE_FOLDER, self.krate_name);
        let file = std::fs::File::create(file_name).expect("Failed to create file");
        serde_json::to_writer(file, rl_graph).expect("Failed to serialize RLGraph");
    }

    /// Merge all the RLGraphs in the folder `RL_SERDE_FOLDER` into a single RLGraph.
    /// The merged RLGraph is serialized into a file named `MERGED_FILE_NAME`.
    pub fn merge_all_rl_graphs() {
        let mut merged_rl_graph: G = G::default();
        let mut rl_graphs = std::fs::read_dir(RL_SERDE_FOLDER)
            .expect("Failed to read folder")
            .map(|entry| entry.expect("Failed to read entry"))
            .collect::<Vec<_>>();
        // It is important to sort the files to have a deterministic order
        rl_graphs.sort_by_key(|a| a.path());

        for rl_graph in rl_graphs {
            let file = std::fs::File::open(rl_graph.path()).expect("Failed to open file");
            let rl_graph: G = serde_json::from_reader(file).expect("Failed to deserialize RLGraph");
            merged_rl_graph.merge(&rl_graph);
        }

        let file_name = format!("{}/{}.rlg", RL_SERDE_FOLDER, MERGED_FILE_NAME);
        let file = std::fs::File::create(file_name).expect("Failed to create file");
        serde_json::to_writer(file, &merged_rl_graph).expect("Failed to serialize RLGraph");
    }

    pub fn deserialized_rl_graph_from_file(file_path: &str) -> G {
        let file = std::fs::File::open(file_path).expect("Failed to open file");
        serde_json::from_reader(file).expect("Failed to deserialize RLGraph")
    }

    pub fn clear_rl_folder() {
        match std::fs::remove_dir_all(RL_SERDE_FOLDER) {
            Ok(_) => {}
            Err(e) => {
                if e.kind() != std::io::ErrorKind::NotFound {
                    panic!("Failed to remove folder");
                }
            }
        }
    }

    pub fn run(&self) {
        let start_time = std::time::Instant::now();
        let rl_graph = self.visitor();
        self.analyzer.rl_graph.set(Some(rl_graph.clone()));
        let elapsed = start_time.elapsed();
        self.elapsed.set(Some(elapsed));
        self.serialize_rl_graph_to_file(&rl_graph);
    }
}
